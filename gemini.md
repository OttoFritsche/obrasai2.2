# üß† Contexto e Regras do Projeto ObrasAI

Este documento centraliza as informa√ß√µes, regras e conven√ß√µes para o
desenvolvimento do projeto ObrasAI.

**Regra Essencial:** Sempre me comunicar em **portugu√™s brasileiro**.

---

## üéØ Vis√£o Geral do Projeto

- **Produto:** ObrasAI √© uma plataforma SaaS completa para gest√£o de obras na
  constru√ß√£o civil, com foco em automa√ß√£o, controle de custos e intelig√™ncia
  artificial especializada.
- **Status Atual:** O sistema principal (v2.2) est√° **100% implementado e
  funcional**, incluindo m√≥dulos de gest√£o, IA contextual, captura de leads,
  or√ßamento param√©trico, sistema SINAPI, assinaturas e contratos inteligentes.
- **Miss√£o:** Revolucionar a gest√£o de obras no Brasil com tecnologia, IA e
  automa√ß√£o.

---

## üõ†Ô∏è Stack Tecnol√≥gica Principal

- **Frontend:** React 18+ com TypeScript, Vite, Tailwind CSS e shadcn/ui.
- **Gerenciamento de Estado:** TanStack Query (React Query).
- **Formul√°rios:** React Hook Form com Zod para valida√ß√£o.
- **Backend & Infra:** Supabase (PostgreSQL, Auth, Storage, Edge Functions em
  Deno/TypeScript).
- **Automa√ß√£o:** n8n Cloud para workflows (ex: captura de leads).
- **APIs de IA:** DeepSeek API.
- **Pagamentos:** Stripe.
- **Tipagem:** Sistema robusto de tipos TypeScript com arquivos centralizados e
  ESLint configurado.

## üö® Regra Cr√≠tica de Arquitetura

- **Limite de Tamanho de Arquivos:** Arquivos n√£o devem exceder **400-500 linhas
  de c√≥digo**. Arquivos maiores devem ser **obrigatoriamente refatorados** em
  m√≥dulos menores para facilitar manuten√ß√£o, legibilidade e evitar complexidade
  excessiva. Aplicar princ√≠pio da responsabilidade √∫nica.

---

## üèóÔ∏è Arquitetura e Estrutura

### Frontend (`src/`)

- `components/`: Componentes reutiliz√°veis (UI, AI, Dashboard, etc.).
- `pages/`: P√°ginas principais da aplica√ß√£o.
- `hooks/`: Custom hooks para l√≥gica de neg√≥cios (`useObras`, `useContratoAI`,
  etc.).
- `services/`: Comunica√ß√£o com APIs externas (Supabase, IA, etc.).
- `lib/`: Utilit√°rios, valida√ß√µes e configura√ß√µes.
- `contexts/`: Contextos globais da aplica√ß√£o.
- `types/`: **Sistema centralizado de tipos TypeScript** (`forms.ts`, `api.ts`,
  `alerts.ts`, `supabase.ts`, `index.ts`).

### Backend (`supabase/`)

- `functions/`: Mais de 27 Edge Functions para l√≥gicas espec√≠ficas (ex:
  `ai-chat`, `contrato-ai-assistant`, `gerar-contrato-pdf`).
- `migrations/`: Migra√ß√µes do banco de dados PostgreSQL.

### Banco de Dados (Tabelas Principais)

- `leads`: Captura de leads do chatbot.
- `obras`: Gerenciamento das obras.
- `contratos`: Contratos inteligentes com hist√≥rico e status.
- `ia_contratos_interacoes`: Log e analytics de todas as intera√ß√µes com a IA de
  contratos.
- `embeddings_conhecimento`: Vetores de embeddings para busca sem√¢ntica
  (documenta√ß√£o, etc.).
- Outras: `fornecedores_pj`, `fornecedores_pf`, `despesas`, `notas_fiscais`,
  etc.

---

## ‚öôÔ∏è Comandos Essenciais

- **Instalar depend√™ncias:** `npm install`
- **Rodar ambiente de desenvolvimento:** `npm run dev`
- **Build para produ√ß√£o:** `npm run build`
- **Verificar qualidade do c√≥digo:** `npm run lint`
- **Verificar tipagem TypeScript:** `npm run type-check`
- **Corrigir problemas automaticamente:** `npm run lint -- --fix`
- **Criar uma nova migra√ß√£o Supabase:**
  `supabase migration new <nome_da_migracao>`
- **Aplicar migra√ß√µes no banco local:** `supabase db push`
- **Deploy de uma Edge Function:** `supabase functions deploy <nome_da_funcao>`

---

## üîÑ Processo de Desenvolvimento e Git

- **Branches:** Seguir o padr√£o `feature/`, `fix/`, `hotfix/`.
- **Commits:** Usar commits sem√¢nticos (`feat:`, `fix:`, `docs:`, `refactor:`).
- **Pull Requests (PRs):** Revis√£o de c√≥digo √© obrigat√≥ria antes do merge.
- **Simplicidade:** Priorizar solu√ß√µes simples e diretas (KISS). Evitar
  complexidade desnecess√°ria, especialmente em fluxos n8n.

---

## üõ°Ô∏è Regras de Seguran√ßa (Cr√≠tico)

- **Row Level Security (RLS):** RLS √© **obrigat√≥rio** em todas as tabelas para
  garantir o isolamento de dados (multi-tenant).
- **Valida√ß√£o de Dados:** Realizar valida√ß√£o dupla: no frontend (para UX) e no
  backend (para seguran√ßa).
- **Gerenciamento de Segredos:** **Nunca** fazer commit de chaves de API, tokens
  ou segredos. Utilizar vari√°veis de ambiente do Supabase.
- **LGPD:** A coleta de dados (leads) deve ser compat√≠vel com a LGPD, informando
  a finalidade e garantindo o consentimento.

---

## ü§ñ Diretrizes para a IA (Gemini)

1. **Analisar Antes de Agir:** Sempre analisar o c√≥digo existente na base para
   entender a estrutura e as conven√ß√µes antes de propor uma solu√ß√£o.
2. **Priorizar o Existente:** Antes de sugerir novas bibliotecas ou tecnologias,
   verificar se a funcionalidade pode ser implementada com a stack atual (React,
   Supabase, n8n).
3. **Explicar o "Porqu√™":** N√£o apenas mostrar o c√≥digo, mas justificar as
   decis√µes t√©cnicas, especialmente em rela√ß√£o √† arquitetura e seguran√ßa.
4. **Foco na Simplicidade e Manutenibilidade:** Propor solu√ß√µes claras,
   eficientes e f√°ceis de manter, alinhadas com os princ√≠pios do projeto.
5. **Seguran√ßa em Primeiro Lugar:** Ser proativo na identifica√ß√£o e
   implementa√ß√£o de pr√°ticas de seguran√ßa, especialmente RLS e valida√ß√£o de
   dados.
6. **Testes:** Para novas funcionalidades, sempre sugerir uma estrat√©gia de
   teste pr√°tica, mesmo que manual, para validar o fluxo completo (ex: testar a
   captura de um lead desde o chatbot at√© o recebimento do email).

---

## üìù Conven√ß√µes de Tipagem TypeScript

### **Estrutura de Tipos:**

- **`src/types/forms.ts`**: Tipos para formul√°rios, props e valida√ß√£o
- **`src/types/api.ts`**: Tipos para APIs, responses e requests
- **`src/types/alerts.ts`**: Sistema completo de alertas avan√ßados
- **`src/types/supabase.ts`**: Tipos espec√≠ficos do Supabase e realtime
- **`src/types/index.ts`**: Exporta√ß√£o central e utility types

### **Padr√µes de Nomenclatura:**

- **Interface para props:** `interface ComponentProps { ... }`
- **Interface para objetos:** `interface UserData { ... }`
- **Type para unions:** `type Status = 'pending' | 'completed' | 'error'`
- **Type para aliases:** `type WithId<T> = T & { id: string }`

### **Regras Essenciais:**

- **Proibido uso de `any`** - sempre usar tipos espec√≠ficos
- **Preferir `interface`** para defini√ß√µes de objetos
- **Usar `type`** para union types e aliases
- **Importar tipos** com `import type` quando poss√≠vel
- **FormWrapper gen√©rico** com `<T = Record<string, unknown>>`

### **ESLint Configurado:**

```javascript
"@typescript-eslint/no-explicit-any": "error"
"@typescript-eslint/consistent-type-definitions": ["error", "interface"]
"@typescript-eslint/consistent-type-imports": "error"
```

### **Utility Types Dispon√≠veis:**

- `WithId<T>`: Adiciona campo id
- `WithTimestamps<T>`: Adiciona created_at/updated_at
- `WithUser<T>`: Adiciona usuario_id/tenant_id
- `DatabaseEntity<T>`: Combina√ß√£o completa para entidades do banco
- `CreateInput<T>`: Remove campos auto-gerados para cria√ß√£o
- `UpdateInput<T>`: Campos opcionais para atualiza√ß√£o

### **Exemplos de Uso:**

```typescript
// ‚úÖ Correto - Interface para props
interface ObraFormProps {
  onSubmit: (data: ObraFormData) => void;
  initialData?: Partial<ObraFormData>;
  isLoading?: boolean;
}

// ‚úÖ Correto - FormWrapper gen√©rico
<FormWrapper<ObraFormData>
  form={form}
  onSubmit={handleSubmit}
  title="Nova Obra"
>
  {/* campos do formul√°rio */}
</FormWrapper>;

// ‚úÖ Correto - Utility types
type NovaObra = CreateInput<ObraFormData>;
type AtualizarObra = UpdateInput<ObraFormData>;

// ‚ùå Incorreto - uso de any
// const handleSubmit = (data: any) => { ... }
```

---

## ‚úÖ Checklist de Boas Pr√°ticas de C√≥digo

1. **Evitar Duplica√ß√£o de C√≥digo (DRY):** Utilizar componentes, hooks e fun√ß√µes
   reutiliz√°veis para evitar a repeti√ß√£o de l√≥gica.
2. **Eliminar C√≥digo N√£o Utilizado (Dead Code):** Remover componentes, fun√ß√µes,
   imports e vari√°veis de estado que n√£o s√£o usados.
3. **Uso Consistente de TypeScript:** Proibir o uso de `any`, tipar todas as
   props e usar `interface` para objetos e `type` para uni√µes/aliases.
4. **Componentes Bem Estruturados:** Manter componentes pequenos e focados
   (m√°ximo de 250 linhas), seguindo o princ√≠pio da responsabilidade √∫nica.
5. **Gerenciamento de Estado Eficiente:** Usar `TanStack Query` para estado do
   servidor e `Context API` de forma modular para estado global. Evitar "prop
   drilling".
6. **Uso Correto de React Hooks:** Seguir as regras dos hooks, gerenciar
   depend√™ncias (`useEffect`, `useCallback`) e criar custom hooks para l√≥gicas
   complexas.
7. **Separa√ß√£o de L√≥gica e Apresenta√ß√£o:** Isolar a l√≥gica de neg√≥cio em hooks e
   servi√ßos, mantendo os componentes focados na UI.
8. **Tratamento de Erros Robusto:** Usar `try/catch` em chamadas de API,
   implementar `Error Boundaries` e fornecer feedback claro ao usu√°rio.
9. **Performance e Otimiza√ß√µes:** Utilizar `React.memo`, `useCallback`,
   `useMemo` quando necess√°rio, virtualizar listas longas e otimizar imagens.
10. **Estrutura e Organiza√ß√£o do Projeto:** Seguir a estrutura de arquivos e
    pastas definida, evitando depend√™ncias circulares e arquivos muito grandes.
11. **Acessibilidade (a11y):** Garantir que a aplica√ß√£o seja acess√≠vel, com
    labels, `alt` text para imagens, sem√¢ntica HTML correta e navega√ß√£o por
    teclado.
12. **Testes Adequados (ver se√ß√£o de testes).**

---

## üõ°Ô∏è Checklist de Seguran√ßa (Cr√≠tico)

1. **Proteger Chaves e Dados Sens√≠veis:** **Nunca** fazer commit de segredos.
   Usar vari√°veis de ambiente (`.env`) e garantir que `.gitignore` as exclua.
2. **N√£o Expor APIs no Frontend:** Toda a l√≥gica sens√≠vel e chamadas de API com
   chaves devem ser feitas no backend (Edge Functions).
3. **Valida√ß√£o de Dados de Entrada:** Validar **TODOS** os inputs no frontend
   (Zod) e no backend para prevenir inje√ß√£o de dados maliciosos.
4. **Autentica√ß√£o e Autoriza√ß√£o (RLS):** **RLS √© obrigat√≥rio em todas as
   tabelas**. Verificar permiss√µes em todas as rotas e queries sens√≠veis.
5. **Prote√ß√£o Contra Ataques Comuns:** Usar ORM do Supabase para prevenir SQL
   Injection. Validar e sanitizar dados para prevenir XSS.
6. **Logging Adequado:** Manter logs de eventos cr√≠ticos (logins, erros), mas
   **NUNCA** registrar senhas, tokens ou dados pessoais nos logs.
7. **Pol√≠tica de Senhas Fortes:** Exigir senhas fortes via valida√ß√£o Zod e usar
   o hash seguro do Supabase Auth.
8. **Backup e Recupera√ß√£o de Dados:** Utilizar os backups autom√°ticos do
   Supabase e ter um plano de recupera√ß√£o.
9. **An√°lise de Depend√™ncias:** Manter as depend√™ncias atualizadas e
   periodicamente rodar `npm audit` para encontrar vulnerabilidades.
10. **Comunica√ß√£o Segura (HTTPS):** For√ßar HTTPS em toda a aplica√ß√£o.

---

## üß™ Estrat√©gia de Testes

- **Foco em Testes de Integra√ß√£o:** Priorizar testes que simulam o comportamento
  real do usu√°rio nos componentes React, utilizando a `React Testing Library`.
- **Mocking de API com MSW:** Padronizar o uso do **Mock Service Worker (MSW)**
  para interceptar chamadas de API (`fetch`), tornando os testes realistas e
  independentes do backend.
- **Testes Unit√°rios para L√≥gica Pura:** Cobrir com testes unit√°rios (Vitest)
  toda a l√≥gica de neg√≥cio isolada, especialmente validadores (Zod) e fun√ß√µes
  utilit√°rias (`/lib/utils`).
- **Verifica√ß√£o da UI:** Os testes de integra√ß√£o devem sempre verificar o
  resultado final na interface do usu√°rio (ex: um toast de sucesso aparece, uma
  navega√ß√£o ocorre), em vez de apenas verificar se uma fun√ß√£o mockada foi
  chamada.
- **Cobertura de Fluxos Cr√≠ticos:** Garantir testes de integra√ß√£o para os fluxos
  mais importantes: registro, login, cria√ß√£o de obras, lan√ßamento de despesas,
  etc.

---

## ü§ñ Diretrizes para a IA (Gemini)

1. **Analisar Antes de Agir:** Sempre analisar o c√≥digo existente e as regras
   deste documento antes de propor uma solu√ß√£o.
2. **Priorizar o Existente:** Verificar se a funcionalidade pode ser
   implementada com a stack atual (React, Supabase, n8n) antes de sugerir novas
   tecnologias.
3. **Explicar o "Porqu√™":** Justificar as decis√µes t√©cnicas, especialmente em
   rela√ß√£o √† arquitetura, seguran√ßa e boas pr√°ticas.
4. **Foco na Simplicidade e Manutenibilidade:** Propor solu√ß√µes claras e
   eficientes.
5. **Seguran√ßa e Boas Pr√°ticas Como Prioridade:** Ser proativo na aplica√ß√£o de
   **TODOS** os pontos dos checklists de seguran√ßa e boas pr√°ticas.
6. **Testes:** Para novas funcionalidades, sempre incluir um teste (unit√°rio ou
   de integra√ß√£o) seguindo a estrat√©gia definida.
